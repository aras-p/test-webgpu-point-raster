<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebGPU Point Rasterization</title>
  <style>
    html, body { height: 100%; margin: 0; background:#222; color:#eee; font-family: Arial; }
    header { padding: 8px 12px; }
    canvas { width: 100%; height: 100%; display: block; }
    .error { padding: 16px; color:#e66; }
  </style>
</head>
<body>
    <header>
      <span>WebGPU point rasterization</span>
      <span id="gpu"></span>
      <label style="margin-left:12px;">Points:
        <input type="range" id="count" min="18" max="24" value="20" step="1">
      </label>
      <span id="countLabel" style="margin-left:8px;margin-right:8px;">--</span>
      <label style="margin-left:12px;">Scale:
        <input type="range" id="size" min="1" max="100" value="100" step="1">
      </label>
      <span id="fps">fps: --</span>
    </header>
    <canvas id="gfx"></canvas>

    <script type="module">
      if (!('gpu' in navigator)) {
        document.body.innerHTML = '<div class="error">Your browser does not support WebGPU. Try Chrome/Edge 113+ (desktop).</div>';
        throw new Error('WebGPU is not supported');
      }
      const canvas = document.getElementById('gfx');
      const fpsElem = document.getElementById('fps');
      const countSlider = document.getElementById('count');
      const countLabel  = document.getElementById('countLabel');
      const sizeSlider = document.getElementById('size');

      const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
      if (!adapter) throw new Error('No GPU adapter found.');
      const device = await adapter.requestDevice();
      const context = canvas.getContext('webgpu');
      const format = navigator.gpu.getPreferredCanvasFormat();

      if (adapter.info) {
        const gpuElem = document.getElementById('gpu');
        gpuElem.textContent = `GPU: "${adapter.info.vendor} ${adapter.info.architecture} ${adapter.info.device}"`;
      }

      function configureContext() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const w = Math.floor(canvas.clientWidth * dpr);
        const h = Math.floor(canvas.clientHeight * dpr);
        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w; canvas.height = h;
        }
        context.configure({ device, format, alphaMode: 'opaque' });
      }
      configureContext();
      window.addEventListener('resize', configureContext);

      const shader = /* wgsl */`
struct Uniforms { time: f32, aspect: f32, n: f32, size: f32 };
@group(0) @binding(0) var<uniform> uni : Uniforms;

struct VSOut {
  @builtin(position) pos : vec4f,
  @location(0) color : vec4f,
};

@vertex
fn vsMain(@builtin(vertex_index) vid : u32) -> VSOut {
  let N : u32 = u32(uni.n);
  let i : u32 = vid % N;          // column
  let j : u32 = vid / N;          // row
  let u : f32 = (f32(i) / f32(max(N,1) - 1u)) * 2.0 - 1.0;
  let v : f32 = (f32(j) / f32(max(N,1) - 1u)) * 2.0 - 1.0;

  // procedural displacement
  let dx = 0.02 * sin(10.0 * u + uni.time) * cos(6.0 * v + uni.time * 1.3);
  let dy = 0.02 * sin(8.0 * v + uni.time * 0.7) * cos(5.0 * u - uni.time * 0.6);

  var out : VSOut;
  out.pos = vec4f(((u + dx) / uni.aspect) * uni.size, (v + dy) * uni.size, 0.0, 1.0);
  let hue = fract((f32(vid) * 0.0008) + uni.time * 0.02);
  out.color = vec4f(0.5 + abs(dx)*40, 0.5 + abs(dy)*40, 0.5, 1.0/(log2(uni.n)-8));
  return out;
}

@fragment
fn fsMain(in : VSOut) -> @location(0) vec4f {
  return in.color;
}
`;

    const module = device.createShaderModule({ code: shader });

    const pipeline = device.createRenderPipeline({
      layout: 'auto',
      vertex: { module, entryPoint: 'vsMain' },
      fragment: { module, entryPoint: 'fsMain',
        targets: [{
          format,
          blend: {
            color: { srcFactor: 'src-alpha', dstFactor: 'one', operation: 'add' },
            alpha: { srcFactor: 'src-alpha', dstFactor: 'one', operation: 'add' },
          },
        }]
      },
      primitive: { topology: 'point-list' },
    });

    const uniformBufferSize = 16; // 4x f32
    const uniformBuffer = device.createBuffer({
      size: uniformBufferSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    const bindGroup = device.createBindGroup({
      layout: pipeline.getBindGroupLayout(0),
      entries: [{ binding: 0, resource: { buffer: uniformBuffer } }],
    });

    // Point count: 2^N points
    let N = 20;
    function setN(v) {
      N = Math.max(1, Math.floor(v));
      countLabel.textContent = (1<<N).toLocaleString();
    }
    setN(N);
    countSlider.addEventListener('input', (e) => setN(e.target.value));

    let size = 100.0;
    function setSize(v) {
      size = v;
    }
    sizeSlider.addEventListener('input', (e) => setSize(e.target.value));

    let lastTime = 0;
    let lastUpdate = 0;
    function frame(tMS) {
      // FPS / time measurement
      const dt = tMS - lastTime;
      lastTime = tMS;
      if (tMS - lastUpdate > 500) {
        lastUpdate = tMS;
        const fps = dt > 0 ? (1000 / dt).toFixed(1) : '--';
        fpsElem.textContent = `Time: ${dt.toFixed(1)} ms (${fps} FPS)`;
      }

      const time = tMS * 0.001; // seconds
      const aspect = canvas.width / canvas.height;
      const data = new Float32Array([time, aspect, Math.sqrt(1<<N), size / 100.0]);
      device.queue.writeBuffer(uniformBuffer, 0, data.buffer);

      const encoder = device.createCommandEncoder();
      const pass = encoder.beginRenderPass({
        colorAttachments: [{
          view: context.getCurrentTexture().createView(),
          loadOp: 'clear',
          storeOp: 'store',
          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1 },
        }],
      });

      pass.setPipeline(pipeline);
      pass.setBindGroup(0, bindGroup);
      pass.draw(1 << N);
      pass.end();

      device.queue.submit([encoder.finish()]);
      requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);
  </script>
</body>
</html>
