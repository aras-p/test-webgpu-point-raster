<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebGPU Point Rasterization</title>
  <style>
    body { margin: 5px; font-family: Arial; }
    canvas { border: 1px solid #888; width: 512px; height: 512px; display: block; }
    table { border-collapse: collapse; }
    .error { padding: 16px; color:#e66; }
  </style>
</head>
<body>
    <p>
      <span>WebGPU point rasterization</span>
      <span id="gpu"></span>
      <div>
        <label">Points:
          <input type="range" id="count" min="18" max="24" value="22" step="1">
        </label>
        <span id="countLabel">--</span>
      </div>
      <div>
        <label>Scale:
          <input type="range" id="size" min="1" max="100" value="80" step="1">
        </label>
        <span id="sizeLabel">--</span>
      </div>
      <span id="fps">fps: --</span>
    </p>
    <canvas id="gfx"></canvas>
    <p>
    Data gathered so far:
    <table border="1">
      <tr><td>System</td><td>Default (4M, 80%)</td><td>4M, 1%</td><td>262K, 1%</td><td>1M, 1%</td><td>16M, 80%</td><td>16M, 1%</td></tr>
      <tr><td>Apple M4 Max / Chrome</td><td>8.3</td><td>53.3</td><td>8.3</td><td>13.4</td><td>11.1</td><td>265.0</td></tr>
      <tr><td>iPhone 16 Pro / Safari</td><td>16.6</td><td>95.2</td><td>16.6</td><td>23.5</td><td>56.3</td><td>491.3</td></tr>
      <tr><td>RTX 3080Ti / Chrome</td><td>16.6</td><td>16.6</td><td>16.6</td><td>16.6</td><td>16.6</td><td>38.5</td></tr>
    </table>
    </p>

    <script type="module">
      if (!('gpu' in navigator)) {
        document.body.innerHTML = '<div class="error">Your browser does not support WebGPU. Try Chrome/Edge 113+ (desktop).</div>';
        throw new Error('WebGPU is not supported');
      }
      const canvas = document.getElementById('gfx');
      const fpsElem = document.getElementById('fps');
      const countSlider = document.getElementById('count');
      const countLabel  = document.getElementById('countLabel');
      const sizeSlider = document.getElementById('size');
      const sizeLabel  = document.getElementById('sizeLabel');

      const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
      if (!adapter) throw new Error('No GPU adapter found.');

      const canTimestamp = adapter.features.has('timestamp-query');

      const device = await adapter.requestDevice({
        requiredFeatures: [
          ...(canTimestamp ? ['timestamp-query'] : []),
        ],
      });      
      const context = canvas.getContext('webgpu');
      const format = navigator.gpu.getPreferredCanvasFormat();

      if (adapter.info) {
        const gpuElem = document.getElementById('gpu');
        gpuElem.textContent = `GPU: "${adapter.info.vendor} ${adapter.info.architecture} ${adapter.info.device}"`;
      }

      function configureContext() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const w = Math.floor(canvas.clientWidth * dpr);
        const h = Math.floor(canvas.clientHeight * dpr);
        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w; canvas.height = h;
        }
        context.configure({ device, format, alphaMode: 'opaque' });
      }
      configureContext();
      //window.addEventListener('resize', configureContext);

      const shader = /* wgsl */`
struct Uniforms { time: f32, n: f32, size: f32, pad: f32 };
@group(0) @binding(0) var<uniform> uni : Uniforms;

struct VSOut {
  @builtin(position) pos : vec4f,
  @location(0) color : vec4f,
};

@vertex
fn vsMain(@builtin(vertex_index) vid : u32) -> VSOut {
  let N : u32 = u32(uni.n);
  let i : u32 = vid % N;          // column
  let j : u32 = vid / N;          // row
  let u : f32 = (f32(i) / f32(max(N,1) - 1u)) * 2.0 - 1.0;
  let v : f32 = (f32(j) / f32(max(N,1) - 1u)) * 2.0 - 1.0;

  // procedural displacement
  let dx = 0.02 * sin(10.0 * u + uni.time) * cos(6.0 * v + uni.time * 1.3);
  let dy = 0.02 * sin(8.0 * v + uni.time * 0.7) * cos(5.0 * u - uni.time * 0.6);

  var out : VSOut;
  out.pos = vec4f((u + dx) * uni.size, (v + dy) * uni.size, 0.0, 1.0);
  let hue = fract((f32(vid) * 0.0008) + uni.time * 0.02);
  out.color = vec4f(0.5 + abs(dx)*40, 0.5 + abs(dy)*40, 0.5, 1.0/(log2(uni.n)-5));
  return out;
}

@fragment
fn fsMain(in : VSOut) -> @location(0) vec4f {
  return in.color;
}
`;

    const module = device.createShaderModule({ code: shader });

    const pipeline = device.createRenderPipeline({
      layout: 'auto',
      vertex: { module, entryPoint: 'vsMain' },
      fragment: { module, entryPoint: 'fsMain',
        targets: [{
          format,
          blend: {
            color: { srcFactor: 'src-alpha', dstFactor: 'one', operation: 'add' },
            alpha: { srcFactor: 'src-alpha', dstFactor: 'one', operation: 'add' },
          },
        }]
      },
      primitive: { topology: 'point-list' },
    });

    const uniformBufferSize = 16; // 4x f32
    const uniformBuffer = device.createBuffer({
      size: uniformBufferSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    const bindGroup = device.createBindGroup({
      layout: pipeline.getBindGroupLayout(0),
      entries: [{ binding: 0, resource: { buffer: uniformBuffer } }],
    });

    // from https://webgpufundamentals.org/webgpu/lessons/webgpu-timing.html
    const { querySet, resolveBuffer, resultBuffer } = (() => {
      if (!canTimestamp) {
        return {};
      }
      const querySet = device.createQuerySet({
         type: 'timestamp',
         count: 2,
      });
      const resolveBuffer = device.createBuffer({
        size: querySet.count * 8,
        usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,
      });
      const resultBuffer = device.createBuffer({
        size: resolveBuffer.size,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
      });
      return {querySet, resolveBuffer, resultBuffer };
    })();    

    const renderPassDescriptor = {
      colorAttachments: [
        {
          clearValue: [0.0, 0.0, 0.0, 1],
          loadOp: 'clear',
          storeOp: 'store',
        },
      ],
      ...(canTimestamp && {
        timestampWrites: {
          querySet,
          beginningOfPassWriteIndex: 0,
          endOfPassWriteIndex: 1,
        },
      }),
    };

    // Point count: 2^N points
    let N = 22;
    function setN(v) {
      N = Math.max(1, Math.floor(v));
      countLabel.textContent = (1<<N).toLocaleString();
    }
    setN(N);
    countSlider.addEventListener('input', (e) => setN(e.target.value));

    let size = 80.0;
    function setSize(v) {
      size = v;
      sizeLabel.textContent = size + '%';
    }
    setSize(size);
    sizeSlider.addEventListener('input', (e) => setSize(e.target.value));

    let lastUpdate = 0;
    let updateCount = 0;
    let gpuTime = 0;
    function frame(tMS) {
      // FPS / time measurement
      updateCount++;
      if (tMS - lastUpdate > 500) {
        const dt = (tMS - lastUpdate) / updateCount;
        lastUpdate = tMS;
        updateCount = 0;
        const fps = dt > 0 ? (1000 / dt).toFixed(1) : '--';
        let fpsText = `Time: ${dt.toFixed(1)} ms (${fps} FPS)`;
        if (canTimestamp) {
          fpsText += ` GPU ${gpuTime.toFixed(1)} ms`;
        }
        fpsElem.textContent = fpsText;
      }

      const time = tMS * 0.001; // seconds
      const data = new Float32Array([time, Math.sqrt(1<<N), size / 100.0, 0.0]);
      device.queue.writeBuffer(uniformBuffer, 0, data.buffer);

      const encoder = device.createCommandEncoder();
      renderPassDescriptor.colorAttachments[0].view =
        context.getCurrentTexture().createView();
      const pass = encoder.beginRenderPass(renderPassDescriptor);

      pass.setPipeline(pipeline);
      pass.setBindGroup(0, bindGroup);
      pass.draw(1 << N);
      pass.end();

      if (canTimestamp) {
        encoder.resolveQuerySet(querySet, 0, querySet.count, resolveBuffer, 0);
        if (resultBuffer.mapState === 'unmapped') {
          encoder.copyBufferToBuffer(resolveBuffer, 0, resultBuffer, 0, resultBuffer.size);
        }
      }

      device.queue.submit([encoder.finish()]);

      if (canTimestamp && resultBuffer.mapState === 'unmapped') {
        resultBuffer.mapAsync(GPUMapMode.READ).then(() => {
          const times = new BigInt64Array(resultBuffer.getMappedRange());
          gpuTime = Number(times[1] - times[0]) / 1000000;
          resultBuffer.unmap();
        });
      }
      requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);
  </script>
</body>
</html>
