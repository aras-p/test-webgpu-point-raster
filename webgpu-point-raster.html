<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebGPU Point Rasterization</title>
  <style>
    body { font-family: Arial; max-width: 50em; margin: auto; background: #333; color: #eee; }
    canvas { border: 1px solid #666; width: 512px; height: 512px; display: block; }
    div { margin-top: 5px; }
    p { margin: 0; margin: 5px 0px; }
    table { border-collapse: collapse; }
    th { background: #222; }
    .error { padding: 16px; color:#e66; }
    .help { border: 1px solid #555; background: #444; padding: 5px; }
    .center { text-align: center; }
  </style>
</head>
<body>
    <h3>WebGPU point rasterization</h3>
    <div class="help">
      <p>
      Render a deforming grid of <i>many</i> points, additively blending them.</p>
      <p>
      There's a checkbox to rasterize points with a compute shader; when it is off
      the regular GPU point rasterization is used. Compute shader path is the most
      na√Øve one: just do atomic writes to screen-sized R,G,B buffers, using fixed
      point colors. There's a resolve pass at the end to turn that into display colors.
      </p>
      <p>
      "Scale" control changes how spread out the points are on screen. It seems that
      with small scale (i.e. <i>lots</i> of points overlapping on the same pixel),
      there is quite a big drop in performance on some GPUs. The compute shader
      path also gets slower, but not as drastically.
      </p>
      <p>
      Buttons change the sliders to some pre-defined scenarios I was measuring.
      </p>
    </div>
    <p>
      <div id="gpu"></div>
      <div id="toggle_compute"><input type="checkbox">Use Compute Shader</input></div>
      <div>
        <button id="btn_1m_90">1M, 90%</button>
        <button id="btn_4m_90">4M, 90%</button>
        <button id="btn_16m_90">16M, 90%</button>
        <button id="btn_1m_1">1M, 1%</button>
        <button id="btn_4m_1">4M, 1%</button>
        <button id="btn_16m_1">16M, 1%</button>
      </div>
      <div>
        <label">Points:
          <input type="range" id="count" min="18" max="24" value="20" step="1">
        </label>
        <span id="countLabel">--</span>
      </div>
      <div>
        <label>Scale:
          <input type="range" id="size" min="1" max="100" value="90" step="1">
        </label>
        <span id="sizeLabel">--</span>
      </div>
      <span id="fps">fps: --</span>
    </p>
    <canvas id="gfx"></canvas>

    <script type="module">
      if (!('gpu' in navigator)) {
        document.body.innerHTML = '<div class="error">Your browser does not support WebGPU.</div>';
        throw new Error('WebGPU is not supported');
      }
      const canvas = document.getElementById('gfx');
      const fpsElem = document.getElementById('fps');
      const countSlider = document.getElementById('count');
      const countLabel  = document.getElementById('countLabel');
      const sizeSlider = document.getElementById('size');
      const sizeLabel  = document.getElementById('sizeLabel');

      const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
      if (!adapter) throw new Error('No GPU adapter found.');

      const canTimestamp = adapter.features.has('timestamp-query');

      const device = await adapter.requestDevice({
        requiredFeatures: [
          ...(canTimestamp ? ['timestamp-query'] : []),
        ],
      });      
      const context = canvas.getContext('webgpu');
      const format = navigator.gpu.getPreferredCanvasFormat();

      if (adapter.info) {
        const gpuElem = document.getElementById('gpu');
        gpuElem.textContent = `GPU: "${adapter.info.vendor} ${adapter.info.architecture} ${adapter.info.device}"`;
      }

      let computeRaster = false;
      let bufferR, bufferG, bufferB;

      function configureContext() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const w = Math.floor(canvas.clientWidth * dpr);
        const h = Math.floor(canvas.clientHeight * dpr);
        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w; canvas.height = h;
        }
        context.configure({ device, format, alphaMode: 'opaque' });
        const pixelCount = canvas.width * canvas.height;
        const bufSize = pixelCount * 4;
        const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST; // COPY_DST needed for clear
        bufferR = device.createBuffer({ size: bufSize, usage });
        bufferG = device.createBuffer({ size: bufSize, usage });
        bufferB = device.createBuffer({ size: bufSize, usage });
      }
      configureContext();
      //window.addEventListener('resize', configureContext);

      const shader = /* wgsl */`
struct Uniforms { time: f32, n: f32, size: f32, pad0: f32, width: u32, height: u32, total: u32, pad2: u32 };
@group(0) @binding(0) var<uniform> uni : Uniforms;

struct VSOut {
  @builtin(position) pos : vec4f,
  @location(0) color : vec4f,
};

@group(0) @binding(1) var<storage, read_write> R : array<atomic<u32>>;
@group(0) @binding(2) var<storage, read_write> G : array<atomic<u32>>;
@group(0) @binding(3) var<storage, read_write> B : array<atomic<u32>>;

@group(0) @binding(4) var<storage, read> Rr : array<u32>;
@group(0) @binding(5) var<storage, read> Gg : array<u32>;
@group(0) @binding(6) var<storage, read> Bb : array<u32>;

@vertex
fn vsMain(@builtin(vertex_index) vid : u32) -> VSOut {
  let N : u32 = u32(uni.n);
  let i : u32 = vid % N;          // column
  let j : u32 = vid / N;          // row
  let u : f32 = (f32(i) / f32(max(N,1) - 1u)) * 2.0 - 1.0;
  let v : f32 = (f32(j) / f32(max(N,1) - 1u)) * 2.0 - 1.0;

  // procedural displacement
  let dx = 0.02 * sin(10.0 * u + uni.time) * cos(6.0 * v + uni.time * 1.3);
  let dy = 0.02 * sin(8.0 * v + uni.time * 0.7) * cos(5.0 * u - uni.time * 0.6);

  var out : VSOut;
  out.pos = vec4f((u + dx) * uni.size, (v + dy) * uni.size, 0.0, 1.0);
  out.color = saturate(vec4f(0.5 + abs(dx)*40, 0.5 + abs(dy)*40, 0.5, 1.0/(log2(uni.n)-5)));
  return out;
}

@fragment
fn fsMain(in : VSOut) -> @location(0) vec4f {
  return in.color;
}

@compute @workgroup_size(16,16)
fn csMain(@builtin(global_invocation_id) gid : vec3<u32>) {
  let i : u32 = gid.x;
  let j : u32 = gid.y;    
  let N : u32 = u32(uni.n);
  if (i >= N || j * N + i >= uni.total) { return; }
  let u : f32 = (f32(i) / f32(max(N,1) - 1u)) * 2.0 - 1.0;
  let v : f32 = (f32(j) / f32(max(N,1) - 1u)) * 2.0 - 1.0;

  // procedural displacement
  let dx = 0.02 * sin(10.0 * u + uni.time) * cos(6.0 * v + uni.time * 1.3);
  let dy = 0.02 * sin(8.0 * v + uni.time * 0.7) * cos(5.0 * u - uni.time * 0.6);

  let x_ndc = (u + dx) * uni.size;
  let y_ndc = (v + dy) * uni.size;
  let x_pix = (x_ndc * 0.5 + 0.5) * f32(uni.width);
  let y_pix = (-y_ndc * 0.5 + 0.5) * f32(uni.height);
  let x = i32(x_pix);
  let y = i32(y_pix);
  if (x < 0 || x >= i32(uni.width) || y < 0 || y >= i32(uni.height)) { return; }

  let idx : u32 = u32(y) * uni.width + u32(x);

  let col : vec4f = saturate(vec4f(0.5 + abs(dx)*40, 0.5 + abs(dy)*40, 0.5, 1.0/(log2(uni.n)-5)));
  let col_r = u32(col.r * col.a * 255.0 + 0.5);
  let col_g = u32(col.g * col.a * 255.0 + 0.5);
  let col_b = u32(col.b * col.a * 255.0 + 0.5);
  atomicAdd(&R[idx], col_r);
  atomicAdd(&G[idx], col_g);
  atomicAdd(&B[idx], col_b);
}

@vertex
fn vsResolve(@builtin(vertex_index) vid : u32) -> @builtin(position) vec4f {
  var p = array<vec2f, 3>(
    vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0)
  );
  return vec4f(p[vid], 0.0, 1.0);
}

@fragment
fn fsResolve(@builtin(position) fragCoord : vec4f) -> @location(0) vec4f {
  let x = u32(clamp(fragCoord.x, 0.0, f32(uni.width - 1u)));
  let y = u32(clamp(fragCoord.y, 0.0, f32(uni.height - 1u)));
  let idx = y * uni.width + x;

  let r = f32(Rr[idx]) / 255.0;
  let g = f32(Gg[idx]) / 255.0;
  let b = f32(Bb[idx]) / 255.0;
  return vec4f(r, g, b, 1.0);
}        
`;

    const module = device.createShaderModule({ code: shader });

    const pipeline = device.createRenderPipeline({
      layout: 'auto',
      vertex: { module, entryPoint: 'vsMain' },
      fragment: { module, entryPoint: 'fsMain',
        targets: [{
          format,
          blend: {
            color: { srcFactor: 'src-alpha', dstFactor: 'one', operation: 'add' },
            alpha: { srcFactor: 'src-alpha', dstFactor: 'one', operation: 'add' },
          },
        }]
      },
      primitive: { topology: 'point-list' },
    });
    const pipelineCs = device.createComputePipeline({
      layout: 'auto',
      compute: { module, entryPoint: 'csMain' }
    });
    const pipelineResolve = device.createRenderPipeline({
      layout: 'auto',
      vertex:   { module, entryPoint: 'vsResolve' },
      fragment: { module, entryPoint: 'fsResolve', targets: [{ format }] },
    });

    const uniformBufferSize = 32; // 4x f32 + 4x u32
    const uniformBuffer = device.createBuffer({
      size: uniformBufferSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    const bindGroup = device.createBindGroup({
      layout: pipeline.getBindGroupLayout(0),
      entries: [{ binding: 0, resource: { buffer: uniformBuffer } }],
    });
    const bindGroupCs = device.createBindGroup({
      layout: pipelineCs.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: uniformBuffer } },
        { binding: 1, resource: { buffer: bufferR } },
        { binding: 2, resource: { buffer: bufferG } },
        { binding: 3, resource: { buffer: bufferB } },
      ],
    });
    const bindGroupResolve = device.createBindGroup({
      layout: pipelineResolve.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: uniformBuffer } },
        { binding: 4, resource: { buffer: bufferR } },
        { binding: 5, resource: { buffer: bufferG } },
        { binding: 6, resource: { buffer: bufferB } },
      ],
    });

    // from https://webgpufundamentals.org/webgpu/lessons/webgpu-timing.html
    const { querySet, resolveBuffer, resultBuffer } = (() => {
      if (!canTimestamp) {
        return {};
      }
      const querySet = device.createQuerySet({
         type: 'timestamp',
         count: 4, // two passes, two timestamps per pass
      });
      const resolveBuffer = device.createBuffer({
        size: querySet.count * 8,
        usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,
      });
      const resultBuffer = device.createBuffer({
        size: resolveBuffer.size,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
      });
      return {querySet, resolveBuffer, resultBuffer };
    })();    

    const renderPassDescriptor = {
      colorAttachments: [
        {
          clearValue: [0.0, 0.0, 0.0, 1],
          loadOp: 'clear',
          storeOp: 'store',
        },
      ],
      ...(canTimestamp && {
        timestampWrites: {
          querySet,
          beginningOfPassWriteIndex: 0,
          endOfPassWriteIndex: 1,
        },
      }),
    };
    const computePassDescriptor = {
      ...(canTimestamp && {
        timestampWrites: {
          querySet,
          beginningOfPassWriteIndex: 2,
          endOfPassWriteIndex: 3,
        },
      }),
    };

    // Point count: 2^N points
    let N = 20;
    function setN(v) {
      N = Math.max(1, Math.floor(v));
      countLabel.textContent = (1<<N).toLocaleString();
      countSlider.value = N;
    }
    setN(N);
    countSlider.addEventListener('input', (e) => setN(e.target.value));

    let size = 90.0;
    function setSize(v) {
      size = v;
      sizeLabel.textContent = size + '%';
      sizeSlider.value = v;
    }
    setSize(size);
    sizeSlider.addEventListener('input', (e) => setSize(e.target.value));

    document.getElementById('btn_1m_90').addEventListener('click', () => {setN(20); setSize(90);});
    document.getElementById('btn_4m_90').addEventListener('click', () => {setN(22); setSize(90);});
    document.getElementById('btn_16m_90').addEventListener('click', () => {setN(24); setSize(90);});
    document.getElementById('btn_1m_1').addEventListener('click', () => {setN(20); setSize(1);});
    document.getElementById('btn_4m_1').addEventListener('click', () => {setN(22); setSize(1);});
    document.getElementById('btn_16m_1').addEventListener('click', () => {setN(24); setSize(1);});
    document.getElementById('toggle_compute').addEventListener('change', (e) => { computeRaster = e.target.checked; });

    let lastUpdate = 0;
    let updateCount = 0;
    let gpuTime = 0;
    let gpuTimeCount = 0;
    let gpuTimeStr = '';
    function frame(tMS) {
      // FPS / time measurement
      updateCount++;
      if (tMS - lastUpdate > 500) {
        const dt = (tMS - lastUpdate) / updateCount;
        const fps = dt > 0 ? (1000 / dt).toFixed(1) : '--';
        if (canTimestamp && gpuTimeCount > 0) {
          gpuTimeStr = ` GPU ${(gpuTime/gpuTimeCount).toFixed(1)} ms`;
          gpuTime = 0;
          gpuTimeCount = 0;
        }
        let fpsText = `Time: ${dt.toFixed(1)} ms (${fps} FPS) ${gpuTimeStr}`;
        fpsElem.textContent = fpsText;
        lastUpdate = tMS;
        updateCount = 0;
      }

      const time = tMS * 0.001; // seconds
      device.queue.writeBuffer(uniformBuffer, 0, new Float32Array([time, Math.sqrt(1<<N), size / 100.0, 0.0]));
      device.queue.writeBuffer(uniformBuffer, 16, new Uint32Array([canvas.width, canvas.height, 1<<N, 0]));

      const encoder = device.createCommandEncoder();

      renderPassDescriptor.colorAttachments[0].view =
        context.getCurrentTexture().createView();

      if (computeRaster) {
        // clear buffers
        encoder.clearBuffer(bufferR);
        encoder.clearBuffer(bufferG);
        encoder.clearBuffer(bufferB);

        // dispatch compute raster
        const cpass = encoder.beginComputePass(computePassDescriptor);
        cpass.setPipeline(pipelineCs);
        cpass.setBindGroup(0, bindGroupCs);
        const cols = Math.floor(Math.sqrt(1<<N));
        const rows = (1<<N) / cols;
        cpass.dispatchWorkgroups(Math.ceil(cols / 16), Math.ceil(rows / 16));
        cpass.end();

        // resolve to screen
        const pass = encoder.beginRenderPass(renderPassDescriptor);
        pass.setPipeline(pipelineResolve);
        pass.setBindGroup(0, bindGroupResolve);
        pass.draw(3); // fullscreen triangle
        pass.end();
      }
      else {
        // regular point raster
        const pass = encoder.beginRenderPass(renderPassDescriptor);
        pass.setPipeline(pipeline);
        pass.setBindGroup(0, bindGroup);
        pass.draw(1 << N);
        pass.end();
      }

      if (canTimestamp) {
        encoder.resolveQuerySet(querySet, 0, querySet.count, resolveBuffer, 0);
        if (resultBuffer.mapState === 'unmapped') {
          encoder.copyBufferToBuffer(resolveBuffer, 0, resultBuffer, 0, resultBuffer.size);
        }
      }

      device.queue.submit([encoder.finish()]);

      if (canTimestamp && resultBuffer.mapState === 'unmapped') {
        resultBuffer.mapAsync(GPUMapMode.READ).then(() => {
          const times = new BigInt64Array(resultBuffer.getMappedRange());
          gpuTime += Number(times[1] - times[0]) / 1000000;
          if (computeRaster) {
            gpuTime += Number(times[3] - times[2]) / 1000000;
          }
          gpuTimeCount++;
          resultBuffer.unmap();
        });
      }
      requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);
  </script>

    <p>
    Data gathered so far is below. Each cell contains GPU time in milliseconds, for
    regular GPU raster / compute shader raster.
    </p>
    <p>
    <table border="1">
      <tr><th>GPU</th>       <th>1M, 90%</th>  <th>4M, 90%</th>  <th>16M, 90%</th>   <th>1M, 1%</th>     <th>4M, 1%</th>     <th>16M, 1%</th></tr>
      <tr><th colspan="7" class="center">NVIDIA</th></tr>
      <tr><td>RTX 5070Ti</td>   <td>0.2 / 0.0</td><td>1.0 / 0.1</td><td>4.8 / 0.7</td>  <td>1.6 / 0.0</td>  <td>6.8 / 0.1</td>  <td>28.5 / 0.2</td></tr>
      <tr><td>RTX 4080</td>     <td>0.8 / 0.1</td><td>1.2 / 0.6</td><td>5.3 / 1.2</td>  <td>1.6 / 0.3</td>  <td>7.2 / 1.1</td>  <td>27.3 / 3.7</td></tr>
      <tr><td>RTX 3080Ti</td>   <td>1.3 / 0.8</td><td>5.3 / 3.1</td><td>6.4 / 5.3</td>  <td>5.7 / 2.3</td>  <td>9.2 / 3.9</td>  <td>37.7 / 6.2</td></tr>
      <tr><td>RTX 4070 laptop</td><td>2.9 / 0.3</td><td>5.9 / 3.3</td><td>10.3 / 6.5</td>  <td>10.0 / 1.2</td>  <td>12.6 / 5.0</td>  <td>33.7 / 14.1</td></tr>
      <tr><td>RTX 4060</td>     <td>6.8 / 1.9</td><td>8.4 / 6.8</td><td>10.0 / 6.1</td>  <td>8.5 / 2.9</td>  <td>7.0 / 6.9</td>  <td>28.2 / 7.5</td></tr>
      <tr><td>GTX 1060</td>     <td>1.8 / 0.4</td><td>9.0 / 3.2</td><td>15.7 / 6.1</td>  <td>6.8 / 0.5</td>  <td>10.4 / 2.6</td>  <td>41.9 / 8.9</td></tr>
      <tr><th colspan="7" class="center">Apple</th></tr>
      <tr><td>M4 Max</td> <td>1.7 / 0.2</td><td>4.5 / 0.8</td><td>12.4 / 4.8</td> <td>21.8 / 2.5</td> <td>87.4 / 10.2</td><td>351.0 / 15.2</td></tr>
      <tr><td>M1 Max</td> <td>1.3 / 0.5</td><td>4.9 / 2.9</td><td>11.1 / 10.8</td> <td>15.6 / 2.9</td> <td>62.5 / 10.2</td><td>250.3 / 28.0</td></tr>
      <tr><td>M3</td>     <td>2.9 / 1.0</td><td>5.1 / 2.3</td><td>23.1 / 8.0</td>  <td>22.0 / 4.1</td> <td>89.0 / 8.4</td><td>340.3 / 20.5</td></tr>
      <tr><td>A18 Pro (iPhone 16 Pro)</td><td>10.5 / 6.6</td><td>13.1 / 10.4</td><td>61.5 / 15.8</td> <td>33.8 / 18.9</td> <td>102.5 / 17.1</td><td>432.7 / 55.4</td></tr>
      <tr><th colspan="7" class="center">Intel</th></tr>
      <tr><td>Iris Xe</td><td>4.4 / 3.6</td><td>12.5 / 10.6</td><td>68.4 / 35.3</td> <td>12.9 / 11.1</td> <td>44.7 / 22.8</td><td>228.3 / 119.2</td></tr>
      <tr><th colspan="7" class="center">ARM</th></tr>
      <tr><td>Mali-G78 MP20 (Pixel 6)</td><td>6.8 / 2.0</td><td>13.8 / 6.5</td><td>7.1 / 11.5</td> <td>102.6 / 7.7</td> <td>452.2 / 15.8</td><td>? / ?</td></tr>
    </table>    
    </p>
    <p>
    Thanks to Robin van Ee, Jak Boulton, Andrew Willmott, Marcel Wiessler, @Geegaz, @Professor_Stevens, @vfig for providing some of the above results!
    </p>

</body>
</html>
