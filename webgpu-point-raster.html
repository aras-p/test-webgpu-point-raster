<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebGPU Point Rasterization</title>
  <style>
    body { font-family: Arial; max-width: 50em; margin: auto; background: #333; color: #eee; }
    canvas { border: 1px solid #666; width: 512px; height: 512px; display: block; }
    div { margin-top: 5px; }
    p { margin: 0; margin: 10px 0px; }
    table { border-collapse: collapse; border-color: #666; }
    th { background: #222; }
    th, td { padding: 2px;  border-left-color: #ccc; border-right-color: #ccc; }
    tr td:not(:first-child) { text-align: right; }
    tr td:nth-child(2n) {
      border-right: 1px solid #444;
    }
    .error { padding: 16px; color:#e66; }
    .help { border: 1px solid #555; background: #444; padding: 5px; }
    .center { text-align: center; }
  </style>
</head>
<body>
<h3>WebGPU point rasterization</h3>
<div class="help">
  <p>
  Render a deforming grid of <i>many</i> points, additively blending them.</p>
  <p>
  There's a checkbox to rasterize points with a compute shader; when it is off
  the regular GPU point rasterization is used. Compute shader path is the most
  naïve one: just do atomic writes to screen-sized R,G,B buffers, using fixed
  point colors. There's a resolve pass at the end to turn that into display colors.
  </p>
  <p>
  "Scale" control changes how spread out the points are on screen. It seems that
  with small scale (i.e. <i>lots</i> of points overlapping on the same pixel),
  there is quite a big drop in performance on some GPUs. The compute shader
  path also gets slower, but not as drastically.
  </p>
  <p>
  Buttons change the sliders to some pre-defined scenarios I was measuring.
  </p>
  <p>
  ⚠️ Note: it looks like for some people Firefox is reporting incorrect GPU timings (they are about 10x
  lower than they should be). Chrome/Chromium based browsers might give more consistent
  results at this point.
  </p>
</div>
<p>
  <div id="gpu"></div>
  <div id="toggle_compute"><input type="checkbox">Use Compute Shader</input></div>
  <div>
    <button id="btn_1m_90">1M, 90%</button>
    <button id="btn_4m_90">4M, 90%</button>
    <button id="btn_16m_90">16M, 90%</button>
    <button id="btn_1m_1">1M, 1%</button>
    <button id="btn_4m_1">4M, 1%</button>
    <button id="btn_16m_1">16M, 1%</button>
  </div>
  <div>
    <label">Points:
      <input type="range" id="count" min="18" max="24" value="20" step="1">
    </label>
    <span id="countLabel">--</span>
  </div>
  <div>
    <label>Scale:
      <input type="range" id="size" min="1" max="100" value="90" step="1">
    </label>
    <span id="sizeLabel">--</span>
  </div>
  <span id="fps">fps: --</span>
</p>
<canvas id="gfx"></canvas>

<script type="module">
  if (!('gpu' in navigator)) {
    document.body.innerHTML = '<div class="error">Your browser does not support WebGPU.</div>';
    throw new Error('WebGPU is not supported');
  }
  const canvas = document.getElementById('gfx');
  const fpsElem = document.getElementById('fps');
  const countSlider = document.getElementById('count');
  const countLabel  = document.getElementById('countLabel');
  const sizeSlider = document.getElementById('size');
  const sizeLabel  = document.getElementById('sizeLabel');

  const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
  if (!adapter) throw new Error('No GPU adapter found.');

  const canTimestamp = adapter.features.has('timestamp-query');

  const device = await adapter.requestDevice({
    requiredFeatures: [
      ...(canTimestamp ? ['timestamp-query'] : []),
    ],
  });      
  const context = canvas.getContext('webgpu');
  const format = navigator.gpu.getPreferredCanvasFormat();

  if (adapter.info) {
    const gpuElem = document.getElementById('gpu');
    gpuElem.textContent = `GPU: "${adapter.info.vendor} ${adapter.info.architecture} ${adapter.info.device}"`;
  }

  let computeRaster = false;
  let bufferR, bufferG, bufferB;

  function configureContext() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const w = Math.floor(canvas.clientWidth * dpr);
    const h = Math.floor(canvas.clientHeight * dpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w; canvas.height = h;
    }
    context.configure({ device, format, alphaMode: 'opaque' });
    const pixelCount = canvas.width * canvas.height;
    const bufSize = pixelCount * 4;
    const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST; // COPY_DST needed for clear
    bufferR = device.createBuffer({ size: bufSize, usage });
    bufferG = device.createBuffer({ size: bufSize, usage });
    bufferB = device.createBuffer({ size: bufSize, usage });
  }
  configureContext();
  //window.addEventListener('resize', configureContext);

  const shader = /* wgsl */`
struct Uniforms { time: f32, n: f32, size: f32, alpha: f32, width: u32, height: u32, total: u32, pad2: u32 };
@group(0) @binding(0) var<uniform> uni : Uniforms;

struct VSOut {
  @builtin(position) pos : vec4f,
  @location(0) color : vec4f,
};

@group(0) @binding(1) var<storage, read_write> R : array<atomic<u32>>;
@group(0) @binding(2) var<storage, read_write> G : array<atomic<u32>>;
@group(0) @binding(3) var<storage, read_write> B : array<atomic<u32>>;

@group(0) @binding(4) var<storage, read> Rr : array<u32>;
@group(0) @binding(5) var<storage, read> Gg : array<u32>;
@group(0) @binding(6) var<storage, read> Bb : array<u32>;

@vertex
fn vsMain(@builtin(vertex_index) vid : u32) -> VSOut {
  let N : u32 = u32(uni.n);
  let i : u32 = vid % N;          // column
  let j : u32 = vid / N;          // row
  let u : f32 = (f32(i) / f32(max(N,1) - 1u)) * 2.0 - 1.0;
  let v : f32 = (f32(j) / f32(max(N,1) - 1u)) * 2.0 - 1.0;

  // procedural displacement
  let dx = 0.02 * sin(10.0 * u + uni.time) * cos(6.0 * v + uni.time * 1.3);
  let dy = 0.02 * sin(8.0 * v + uni.time * 0.7) * cos(5.0 * u - uni.time * 0.6);

  var out : VSOut;
  out.pos = vec4f((u + dx) * uni.size, (v + dy) * uni.size, 0.0, 1.0);
  out.color = saturate(vec4f(0.2 + abs(dx)*80, 0.2 + abs(dy)*80, 0.1, uni.alpha));
  return out;
}

@fragment
fn fsMain(in : VSOut) -> @location(0) vec4f {
  return in.color;
}

@compute @workgroup_size(16,16)
fn csMain(@builtin(global_invocation_id) gid : vec3<u32>) {
  let i : u32 = gid.x;
  let j : u32 = gid.y;    
  let N : u32 = u32(uni.n);
  if (i >= N || j * N + i >= uni.total) { return; }
  let u : f32 = (f32(i) / f32(max(N,1) - 1u)) * 2.0 - 1.0;
  let v : f32 = (f32(j) / f32(max(N,1) - 1u)) * 2.0 - 1.0;

  // procedural displacement
  let dx = 0.02 * sin(10.0 * u + uni.time) * cos(6.0 * v + uni.time * 1.3);
  let dy = 0.02 * sin(8.0 * v + uni.time * 0.7) * cos(5.0 * u - uni.time * 0.6);

  let x_ndc = (u + dx) * uni.size;
  let y_ndc = (v + dy) * uni.size;
  let x_pix = (x_ndc * 0.5 + 0.5) * f32(uni.width);
  let y_pix = (-y_ndc * 0.5 + 0.5) * f32(uni.height);
  let x = i32(x_pix);
  let y = i32(y_pix);
  if (x < 0 || x >= i32(uni.width) || y < 0 || y >= i32(uni.height)) { return; }

  let idx : u32 = u32(y) * uni.width + u32(x);

  let col : vec4f = saturate(vec4f(0.2 + abs(dx)*80, 0.2 + abs(dy)*80, 0.1, uni.alpha));
  let col_r = u32(col.r * col.a * 255.0 + 0.5);
  let col_g = u32(col.g * col.a * 255.0 + 0.5);
  let col_b = u32(col.b * col.a * 255.0 + 0.5);
  atomicAdd(&R[idx], col_r);
  atomicAdd(&G[idx], col_g);
  atomicAdd(&B[idx], col_b);
}

@vertex
fn vsResolve(@builtin(vertex_index) vid : u32) -> @builtin(position) vec4f {
  var p = array<vec2f, 3>(
    vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0)
  );
  return vec4f(p[vid], 0.0, 1.0);
}

@fragment
fn fsResolve(@builtin(position) fragCoord : vec4f) -> @location(0) vec4f {
  let x = u32(clamp(fragCoord.x, 0.0, f32(uni.width - 1u)));
  let y = u32(clamp(fragCoord.y, 0.0, f32(uni.height - 1u)));
  let idx = y * uni.width + x;

  let r = f32(Rr[idx]) / 255.0;
  let g = f32(Gg[idx]) / 255.0;
  let b = f32(Bb[idx]) / 255.0;
  return vec4f(r, g, b, 1.0);
}        
`;

const module = device.createShaderModule({ code: shader });

const pipeline = device.createRenderPipeline({
  layout: 'auto',
  vertex: { module, entryPoint: 'vsMain' },
  fragment: { module, entryPoint: 'fsMain',
    targets: [{
      format,
      blend: {
        color: { srcFactor: 'src-alpha', dstFactor: 'one', operation: 'add' },
        alpha: { srcFactor: 'src-alpha', dstFactor: 'one', operation: 'add' },
      },
    }]
  },
  primitive: { topology: 'point-list' },
});
const pipelineCs = device.createComputePipeline({
  layout: 'auto',
  compute: { module, entryPoint: 'csMain' }
});
const pipelineResolve = device.createRenderPipeline({
  layout: 'auto',
  vertex:   { module, entryPoint: 'vsResolve' },
  fragment: { module, entryPoint: 'fsResolve', targets: [{ format }] },
});

const uniformBufferSize = 32; // 4x f32 + 4x u32
const uniformBuffer = device.createBuffer({
  size: uniformBufferSize,
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
});

const bindGroup = device.createBindGroup({
  layout: pipeline.getBindGroupLayout(0),
  entries: [{ binding: 0, resource: { buffer: uniformBuffer } }],
});
const bindGroupCs = device.createBindGroup({
  layout: pipelineCs.getBindGroupLayout(0),
  entries: [
    { binding: 0, resource: { buffer: uniformBuffer } },
    { binding: 1, resource: { buffer: bufferR } },
    { binding: 2, resource: { buffer: bufferG } },
    { binding: 3, resource: { buffer: bufferB } },
  ],
});
const bindGroupResolve = device.createBindGroup({
  layout: pipelineResolve.getBindGroupLayout(0),
  entries: [
    { binding: 0, resource: { buffer: uniformBuffer } },
    { binding: 4, resource: { buffer: bufferR } },
    { binding: 5, resource: { buffer: bufferG } },
    { binding: 6, resource: { buffer: bufferB } },
  ],
});

// from https://webgpufundamentals.org/webgpu/lessons/webgpu-timing.html
const { querySet, resolveBuffer, resultBuffer } = (() => {
  if (!canTimestamp) {
    return {};
  }
  const querySet = device.createQuerySet({
     type: 'timestamp',
     count: 4, // two passes, two timestamps per pass
  });
  const resolveBuffer = device.createBuffer({
    size: querySet.count * 8,
    usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,
  });
  const resultBuffer = device.createBuffer({
    size: resolveBuffer.size,
    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
  });
  return {querySet, resolveBuffer, resultBuffer };
})();    

const renderPassDescriptor = {
  colorAttachments: [
    {
      clearValue: [0.0, 0.0, 0.0, 1],
      loadOp: 'clear',
      storeOp: 'store',
    },
  ],
  ...(canTimestamp && {
    timestampWrites: {
      querySet,
      beginningOfPassWriteIndex: 0,
      endOfPassWriteIndex: 1,
    },
  }),
};
const computePassDescriptor = {
  ...(canTimestamp && {
    timestampWrites: {
      querySet,
      beginningOfPassWriteIndex: 2,
      endOfPassWriteIndex: 3,
    },
  }),
};

// Point count: 2^N points
let N = 20;
function setN(v) {
  N = Math.max(1, Math.floor(v));
  countLabel.textContent = (1<<N).toLocaleString();
  countSlider.value = N;
}
setN(N);
countSlider.addEventListener('input', (e) => setN(e.target.value));

let size = 90.0;
function setSize(v) {
  size = v;
  sizeLabel.textContent = size + '%';
  sizeSlider.value = v;
}
setSize(size);
sizeSlider.addEventListener('input', (e) => setSize(e.target.value));

document.getElementById('btn_1m_90').addEventListener('click', () => {setN(20); setSize(90);});
document.getElementById('btn_4m_90').addEventListener('click', () => {setN(22); setSize(90);});
document.getElementById('btn_16m_90').addEventListener('click', () => {setN(24); setSize(90);});
document.getElementById('btn_1m_1').addEventListener('click', () => {setN(20); setSize(1);});
document.getElementById('btn_4m_1').addEventListener('click', () => {setN(22); setSize(1);});
document.getElementById('btn_16m_1').addEventListener('click', () => {setN(24); setSize(1);});
document.getElementById('toggle_compute').addEventListener('change', (e) => { computeRaster = e.target.checked; });

let lastUpdate = 0;
let updateCount = 0;
let gpuTime = 0;
let gpuTimeCount = 0;
let gpuTimeStr = '';
function frame(tMS) {
  // FPS / time measurement
  updateCount++;
  if (tMS - lastUpdate > 500) {
    const dt = (tMS - lastUpdate) / updateCount;
    if (canTimestamp && gpuTimeCount > 0) {
      gpuTimeStr = ` GPU ${(gpuTime/gpuTimeCount).toFixed(1)} ms`;
      gpuTime = 0;
      gpuTimeCount = 0;
    }
    let fpsText = `Time: CPU ${dt.toFixed(1)} ms ${gpuTimeStr}`;
    fpsElem.textContent = fpsText;
    lastUpdate = tMS;
    updateCount = 0;
  }

  const time = tMS * 0.001; // seconds
  const alpha = Math.max(1.0/(N-17) * size / 100.0, 2.0/255.0);
  device.queue.writeBuffer(uniformBuffer, 0, new Float32Array([time, Math.sqrt(1<<N), size / 100.0, alpha]));
  device.queue.writeBuffer(uniformBuffer, 16, new Uint32Array([canvas.width, canvas.height, 1<<N, 0]));

  const encoder = device.createCommandEncoder();

  renderPassDescriptor.colorAttachments[0].view =
    context.getCurrentTexture().createView();

  if (computeRaster) {
    // clear buffers
    encoder.clearBuffer(bufferR);
    encoder.clearBuffer(bufferG);
    encoder.clearBuffer(bufferB);

    // dispatch compute raster
    const cpass = encoder.beginComputePass(computePassDescriptor);
    cpass.setPipeline(pipelineCs);
    cpass.setBindGroup(0, bindGroupCs);
    const cols = Math.floor(Math.sqrt(1<<N));
    const rows = (1<<N) / cols;
    cpass.dispatchWorkgroups(Math.ceil(cols / 16), Math.ceil(rows / 16));
    cpass.end();

    // resolve to screen
    const pass = encoder.beginRenderPass(renderPassDescriptor);
    pass.setPipeline(pipelineResolve);
    pass.setBindGroup(0, bindGroupResolve);
    pass.draw(3); // fullscreen triangle
    pass.end();
  }
  else {
    // regular point raster
    const pass = encoder.beginRenderPass(renderPassDescriptor);
    pass.setPipeline(pipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(1 << N);
    pass.end();
  }

  if (canTimestamp) {
    encoder.resolveQuerySet(querySet, 0, querySet.count, resolveBuffer, 0);
    if (resultBuffer.mapState === 'unmapped') {
      encoder.copyBufferToBuffer(resolveBuffer, 0, resultBuffer, 0, resultBuffer.size);
    }
  }

  device.queue.submit([encoder.finish()]);

  if (canTimestamp && resultBuffer.mapState === 'unmapped') {
    resultBuffer.mapAsync(GPUMapMode.READ).then(() => {
      const times = new BigInt64Array(resultBuffer.getMappedRange());
      gpuTime += Number(times[1] - times[0]) / 1000000;
      if (computeRaster) {
        gpuTime += Number(times[3] - times[2]) / 1000000;
      }
      gpuTimeCount++;
      resultBuffer.unmap();
    });
  }
  requestAnimationFrame(frame);
}

requestAnimationFrame(frame);
</script>

<p>
Data gathered so far is below. Each case contains GPU time in milliseconds, for
regular GPU raster and compute shader raster.
</p>
<p>
<table border="1">
  <tr><th>GPU Model</th>                <th colspan="2">1M, 90%</th>  <th colspan="2">4M, 90%</th>  <th colspan="2">16M, 90%</th> <th colspan="2">1M, 1%</th> <th colspan="2">4M, 1%</th> <th colspan="2">16M, 1%</th></tr>
  <tr><th colspan="13" class="center">NVIDIA</th></tr>
  <tr><td>RTX 5070Ti</td>               <td>0.2</td>  <td>0.0</td>    <td>1.0</td>  <td>0.1</td>    <td>4.8</td>  <td>0.7</td>    <td>1.6</td> <td>0.0</td>   <td>6.8</td>  <td>0.1</td>  <td>28.5</td> <td>0.2</td></tr>
  <tr><td>RTX 4080</td>                 <td>0.8</td>  <td>0.1</td>    <td>1.2</td>  <td>0.6</td>    <td>5.3</td>  <td>1.2</td>    <td>1.6</td> <td>0.3</td>   <td>7.2</td>  <td>1.1</td>  <td>27.3</td> <td>3.7</td></tr>
  <tr><td>RTX 3080Ti</td>               <td>1.3</td>  <td>0.8</td>    <td>5.3</td>  <td>3.1</td>    <td>6.4</td>  <td>5.3</td>    <td>5.7</td> <td>2.3</td>   <td>9.2</td>  <td>3.9</td>  <td>37.7</td> <td>6.2</td></tr>
  <tr><td>RTX 3070Ti</td>               <td>1.2</td>  <td>0.8</td>    <td>2.4</td>  <td>1.4</td>    <td>7.8</td>  <td>2.5</td>    <td>2.6</td> <td>1.3</td>   <td>10.3</td> <td>2.3</td>  <td>40.3</td> <td>5.4</td></tr>
  <tr><td>RTX 4070 laptop</td>          <td>2.9</td>  <td>0.3</td>    <td>5.9</td>  <td>3.3</td>    <td>10.3</td> <td>6.5</td>    <td>10.0</td><td>1.2</td>   <td>12.6</td> <td>5.0</td>  <td>33.7</td> <td>14.1</td></tr>
  <tr><td>RTX 4060</td>                 <td>6.8</td>  <td>1.9</td>    <td>8.4</td>  <td>6.8</td>    <td>10.0</td> <td>6.1</td>    <td>8.5</td> <td>2.9</td>   <td>7.0</td>  <td>6.9</td>  <td>28.2</td> <td>7.5</td></tr>
  <tr><td>RTX 2070 Super</td>           <td>1.0</td>  <td>0.2</td>    <td>2.5</td>  <td>1.0</td>    <td>13.0</td> <td>2.7</td>    <td>2.8</td> <td>0.9</td>   <td>11.4</td> <td>1.6</td>  <td>45.2</td> <td>8.2</td></tr>
  <tr><td>RTX 2060</td>                 <td>0.9</td>  <td>0.2</td>    <td>4.7</td>  <td>0.9</td>    <td>15.5</td> <td>4.6</td>    <td>4.7</td> <td>1.7</td>   <td>10.1</td> <td>2.5</td>  <td>41.6</td> <td>7.9</td></tr>
  <tr><td>GTX 1060</td>                 <td>1.8</td>  <td>0.4</td>    <td>9.0</td>  <td>3.2</td>    <td>15.7</td> <td>6.1</td>    <td>6.8</td> <td>0.5</td>   <td>10.4</td> <td>2.6</td>  <td>41.9</td> <td>8.9</td></tr>
  <tr><th colspan="13" class="center">AMD</th></tr>
  <tr><td>RX 9070 XT</td>               <td>0.2</td>  <td>0.0</td>    <td>1.7</td>  <td>0.1</td>    <td>7.3</td>  <td>0.7</td>    <td>3.8</td> <td>0.4</td>   <td>15.0</td> <td>2.1</td>  <td>60.9</td> <td>7.4</td></tr>
  <tr><td>RX 9070</td>                  <td>0.6</td>  <td>0.0</td>    <td>2.6</td>  <td>0.2</td>    <td>9.0</td>  <td>2.1</td>    <td>4.0</td> <td>0.8</td>   <td>15.9</td> <td>2.6</td>  <td>64.0</td> <td>8.0</td></tr>
  <tr><td>RX 7900 XTX</td>              <td>0.4</td>  <td>0.0</td>    <td>2.6</td>  <td>0.2</td>    <td>7.3</td>  <td>1.2</td>    <td>7.7</td> <td>1.0</td>   <td>30.9</td> <td>4.4</td>  <td>123.6</td><td>9.7</td></tr>
  <tr><td>RX 6950 XT</td>               <td>0.9</td>  <td>0.2</td>    <td>4.1</td>  <td>1.0</td>    <td>6.5</td>  <td>4.0</td>    <td>4.3</td> <td>3.1</td>   <td>15.5</td> <td>4.8</td>  <td>62.0</td> <td>9.4</td></tr>
  <tr><td>RX 9060 XT</td>               <td>0.8</td>  <td>0.1</td>    <td>3.3</td>  <td>0.3</td>    <td>13.3</td> <td>1.9</td>    <td>4.6</td> <td>1.2</td>   <td>14.4</td> <td>2.4</td>  <td>58.2</td> <td>9.8</td></tr>
  <tr><td>RX 7800 XT</td>               <td>1.0</td>  <td>0.1</td>    <td>6.1</td>  <td>0.4</td>    <td>14.5</td> <td>0.9</td>    <td>9.5</td> <td>0.9</td>   <td>17.7</td> <td>4.2</td>  <td>71.1</td> <td>12.5</td></tr>
  <tr><th colspan="13" class="center">Apple</th></tr>
  <tr><td>M4 Max</td>                   <td>1.7</td>  <td>0.2</td>    <td>4.5</td>  <td>0.8</td>    <td>12.4</td> <td>4.8</td>    <td>21.8</td><td>2.5</td>   <td>87.4</td> <td>10.2</td> <td>351.0</td><td>15.2</td></tr>
  <tr><td>M1 Max</td>                   <td>1.3</td>  <td>0.5</td>    <td>4.9</td>  <td>2.9</td>    <td>11.1</td> <td>10.8</td>   <td>15.6</td><td>2.9</td>   <td>62.5</td> <td>10.2</td> <td>250.3</td><td>28.0</td></tr>
  <tr><td>M3</td>                       <td>2.9</td>  <td>1.0</td>    <td>5.1</td>  <td>2.3</td>    <td>23.1</td> <td>8.0</td>    <td>22.0</td><td>4.1</td>   <td>89.0</td> <td>8.4</td>  <td>340.3</td><td>20.5</td></tr>
  <tr><td>A18 Pro</td>                  <td>10.5</td> <td>6.6</td>    <td>13.1</td> <td>10.4</td>   <td>61.5</td> <td>15.8</td>   <td>33.8</td><td>18.9</td>  <td>102.5</td><td>17.1</td> <td>432.7</td><td>55.4</td></tr>
  <tr><td>A17 Pro</td>                  <td>6.8</td>  <td>5.2</td>    <td>14.2</td> <td>7.7</td>    <td>67.2</td> <td>20.5</td>   <td>29.1</td><td>12.2</td>  <td>110.0</td><td>22.5</td> <td>470.0</td><td>64.8</td></tr>
  <tr><th colspan="13" class="center">Intel</th></tr>
  <tr><td>Iris Xe</td>                  <td>4.4</td>  <td>3.6</td>    <td>12.5</td> <td>10.6</td>   <td>68.4</td> <td>35.3</td>   <td>12.9</td><td>11.1</td>  <td>44.7</td> <td>22.8</td> <td>228.3</td><td>119.2</td></tr>
  <tr><td>Alder Lake GT2</td>           <td>2.9</td>  <td>3.8</td>    <td>24.5</td> <td>10.4</td>   <td>191.5</td><td>60.6</td>   <td>53.1</td><td>7.4</td>   <td>213.8</td><td>12.8</td> <td>858.3</td><td>41.5</td></tr>
  <tr><td>gen-12lp</td>                 <td>3.1</td>  <td>6.3</td>    <td>24.2</td> <td>12.8</td>   <td>156.0</td><td>78.2</td>   <td>15.4</td><td>12.6</td>  <td>70.0</td> <td>49.8</td> <td>280.0</td><td>199.0</td></tr>
  <tr><td>gen-12lp (i7-11800H)</td>     <td>12.4</td> <td>7.9</td>    <td>45.1</td> <td>19.9</td>   <td>193.9</td><td>111.5</td>  <td>18.4</td><td>8.5</td>   <td>78.9</td> <td>11.6</td> <td>79.3</td> <td>10.6</td></tr>
  <tr><td>UHD 730</td>                  <td>8.1</td>  <td>5.5</td>    <td>47.5</td> <td>22.5</td>   <td>200.0</td><td>116.5</td>  <td>18.8</td><td>5.7</td>   <td>47.7</td> <td>21.7</td> <td>330.0</td><td>36.5</td></tr>
  <tr><th colspan="13" class="center">ARM</th></tr>
  <tr><td>G715s MC10 (Pixel 8 Pro)</td> <td>8.3</td>  <td>3.2</td>    <td>17.2</td> <td>6.1</td>    <td>92.6</td><td>15.6</td>    <td>34.3</td><td>5.1</td>   <td>112.9</td><td>13.6</td> <td>469.1</td><td>53.1</td></tr>
  <tr><td>G78 MP20 (Pixel 6)</td>       <td>6.8</td>  <td>2.0</td>    <td>13.8</td> <td>6.5</td>    <td>57.1</td><td>11.5</td>    <td>102.6</td><td>7.7</td>  <td>452.2</td><td>15.8</td> <td>?</td>    <td>?</td></tr>
  <tr><td>G710 MP7 (Pixel 7a)</td>      <td>10.2</td> <td>7.3</td>    <td>18.2</td> <td>9.0</td>    <td>69.7</td><td>13.7</td>    <td>14.5</td><td>8.0</td>   <td>78.2</td> <td>13.0</td> <td>394.0</td><td>52.8</td></tr>
</table>    
</p>
<p>
Thanks to:
@ascentress,
Andrew Willmott,
Arseny Kapoulkine,
Brandon Jones,
@Gargaj,
@Geegaz,
@grapefrukt,
@horenmar,
Jak Boulton,
Javier Arevalo,
Marcel Wiessler,
Mikko Mononen,
@NohatCoder,
@Professor_Stevens,
Robin van Ee,
@rokups,
@scoopr,
Simen Storsveen,
Simon Rolfmore,
@squirrelbaffler,
Steve Anichini,
@vfig,
for providing some of the above results!
</p>

</body>
</html>
